import time  # Добавляем модуль времени для работы с временем
from functools import wraps  # Из модуля функциональных инструментов берем функцию обертки

def timeit(method):  # Создаем декоратор timeit, который принимает функцию в качестве аргумента
    @wraps(method)
    def timed(*args, **kw):  # Декоратор timed оборачивает вызов функции и отображает время выполнения в миллисекундах
        ts = time.monotonic()  # Запоминаем текущее время перед началом выполнения функции
        outcome = method(*args, **kw)  # Выполняем функцию с переданными аргументами и сохраняем результат
        te = time.monotonic()  # Запоминаем текущее время после окончания выполнения функции
        ms = (te - ts) * 1000  # Вычисляем время выполнения функции в миллисекундах
        all_args = ', '.join(tuple(f'{a!r}' for a in args)  # Формируем строку из переданных аргументов
                             + tuple(f'{k}={v!r}' for k, v in kw.items()))
        print(f'{method.name}({all_args}): {ms:2.2f} ms')  # Выводим имя функции, переданные аргументы и время выполнения функции
        return outcome  # Возвращаем результат выполнения функции
    return timed  # Возвращаем декорированную функцию

# Применение декоратора:
@timeit
def slow_func(x, y, sleep):  # Определяем функцию slow_func, которую будем декорировать
    time.sleep(sleep)  # Приостанавливаем выполнение на указанное количество секунд
    return x + y  # Возвращаем сумму аргументов x и y

slow_func(10, 20, sleep=2)  # Вызываем декорированную функцию slow_func
